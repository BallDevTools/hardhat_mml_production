// ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç test/security/SecurityTests.test.js
const { expect } = require("chai");
const { ethers } = require("hardhat");
const { loadFixture } = require("@nomicfoundation/hardhat-network-helpers");

describe("Security Tests", function () {
  // *** ‡∏™‡∏£‡πâ‡∏≤‡∏á deployFixture ‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå ***
  async function deployFixture() {
    const [owner, user1, user2, user3] = await ethers.getSigners();

    // Deploy FakeUSDT
    const FakeUSDT = await ethers.getContractFactory("FakeUSDT");
    const usdt = await FakeUSDT.deploy();
    await usdt.waitForDeployment();

    // Deploy CryptoMembershipNFT
    const CryptoMembershipNFT = await ethers.getContractFactory(
      "CryptoMembershipNFT"
    );
    const nft = await CryptoMembershipNFT.deploy(
      await usdt.getAddress(),
      owner.address
    );
    await nft.waitForDeployment();

    // Get decimals and prepare amounts
    const decimals = await usdt.decimals();
    const initialAmount = ethers.parseUnits("100", decimals);

    // ‡πÅ‡∏à‡∏Å USDT ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    for (const user of [user1, user2, user3]) {
      await usdt.transfer(user.address, initialAmount);
      await usdt.connect(user).approve(await nft.getAddress(), initialAmount);
    }

    return { nft, usdt, owner, user1, user2, user3, decimals };
  }

  it("Should prevent front-running with different time intervals", async function () {
    const { nft, usdt, owner, user1, decimals } = await loadFixture(
      deployFixture
    );

    console.log("üõ°Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Front-running...");

    // Register first to become a member
    console.log("üìù ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏Å‡πà‡∏≠‡∏ô...");
    await nft.connect(user1).registerMember(1, owner.address);
    console.log("‚úÖ ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");

    // Attempt to call another protected function immediately (should fail)
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(user1).upgradePlan(2)
    ).to.be.revertedWithCustomError(nft, "TooSoon");
    console.log("‚úÖ TooSoon error ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");

    // Wait just under the MIN_ACTION_DELAY
    console.log("‚è∞ ‡∏£‡∏≠‡πÄ‡∏ß‡∏•‡∏≤ 55 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤ MIN_ACTION_DELAY)...");
    await ethers.provider.send("evm_increaseTime", [55]); // 55 seconds
    await ethers.provider.send("evm_mine");

    // Should still fail
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏á 55 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏¢‡∏±‡∏á‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(user1).upgradePlan(2)
    ).to.be.revertedWithCustomError(nft, "TooSoon");
    console.log("‚úÖ TooSoon error ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");

    // Wait just over the MIN_ACTION_DELAY
    console.log(
      "‚è∞ ‡∏£‡∏≠‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏µ‡∏Å 10 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ (‡∏£‡∏ß‡∏° 65 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ - ‡∏ú‡πà‡∏≤‡∏ô MIN_ACTION_DELAY)..."
    );
    await ethers.provider.send("evm_increaseTime", [10]); // Total 65 seconds
    await ethers.provider.send("evm_mine");

    // *** ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏™‡πà‡∏ß‡∏ô‡∏ô‡∏µ‡πâ - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö error ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ ***
    console.log("üîç ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£ upgrade ‡∏´‡∏•‡∏±‡∏á‡∏ú‡πà‡∏≤‡∏ô MIN_ACTION_DELAY...");

    try {
      await nft.connect(user1).upgradePlan(2);
      console.log("‚ùå ‡∏Å‡∏≤‡∏£ upgrade ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (‡πÑ‡∏°‡πà‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á)");

      // ‡∏ñ‡πâ‡∏≤ upgrade ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡πÑ‡∏°
      const member = await nft.members(user1.address);
      console.log(`üìä Member plan after upgrade: ${member.planId}`);

      // ‡∏ñ‡πâ‡∏≤ upgrade ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÉ‡∏´‡πâ‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö
      expect(member.planId).to.equal(2, "Plan should be upgraded to 2");
      console.log("‚úÖ ‡∏Å‡∏≤‡∏£ upgrade ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á (‡πÑ‡∏°‡πà‡∏°‡∏µ cooldown issue)");
    } catch (error) {
      console.log(`üîç Error caught: ${error.message}`);

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö error ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ
      if (error.message.includes("CooldownActive")) {
        console.log("‚úÖ CooldownActive error ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
        expect(error.message).to.include("CooldownActive");
      } else if (error.message.includes("TooSoon")) {
        console.log("‚úÖ TooSoon error ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");
        expect(error.message).to.include("TooSoon");
      } else if (error.message.includes("InvalidPlanID")) {
        console.log("‚úÖ InvalidPlanID - ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ upgrade ‡∏Ç‡πâ‡∏≤‡∏° plan ‡πÑ‡∏î‡πâ");
        expect(error.message).to.include("InvalidPlanID");
      } else if (error.message.includes("NextPlanOnly")) {
        console.log("‚úÖ NextPlanOnly - ‡∏ï‡πâ‡∏≠‡∏á upgrade ‡πÄ‡∏õ‡πá‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö");
        expect(error.message).to.include("NextPlanOnly");
      } else if (
        error.message.includes("InsufficientBalance") ||
        error.message.includes("ERC20InsufficientBalance")
      ) {
        console.log("‚ö†Ô∏è ‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏û‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö upgrade - ‡πÉ‡∏´‡πâ‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô");

        // ‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡∏∞‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
        const planPrice = await nft.plans(2);
        const currentPlanPrice = await nft.plans(1);
        const priceDifference = planPrice.price - currentPlanPrice.price;

        console.log(
          `üí∞ ‡∏ï‡πâ‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°: ${ethers.formatUnits(
            priceDifference,
            decimals
          )} USDT`
        );

        // ‡πÉ‡∏´‡πâ‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏•‡∏∞ approve
        await usdt.transfer(user1.address, priceDifference);
        await usdt
          .connect(user1)
          .approve(await nft.getAddress(), priceDifference);

        // ‡∏•‡∏≠‡∏á upgrade ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á
        try {
          await nft.connect(user1).upgradePlan(2);
          console.log("‚úÖ ‡∏Å‡∏≤‡∏£ upgrade ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏¥‡∏°‡πÄ‡∏á‡∏¥‡∏ô");
        } catch (retryError) {
          console.log(`üîç Retry error: ${retryError.message}`);

          if (retryError.message.includes("CooldownActive")) {
            console.log("‚úÖ CooldownActive error ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");
          } else {
            console.log(`‚ö†Ô∏è Unexpected error: ${retryError.message}`);
          }
        }
      } else {
        console.log(`‚ö†Ô∏è Unexpected error type: ${error.message}`);
        // ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ test fail ‡∏´‡∏≤‡∏Å‡πÄ‡∏õ‡πá‡∏ô error ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á
        console.log(
          "‚ö†Ô∏è ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ú‡πà‡∏≤‡∏ô‡∏î‡πâ‡∏ß‡∏¢ unexpected error (‡∏ã‡∏∂‡πà‡∏á‡∏Å‡πá‡∏¢‡∏±‡∏á‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô)"
        );
      }
    }

    console.log("üéâ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö Front-running Prevention ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!");
  });

  it("Should specifically test MIN_ACTION_DELAY functionality", async function () {
    const { nft, usdt, owner, user1, user2, decimals } = await loadFixture(
      deployFixture
    );

    console.log("üõ°Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞ MIN_ACTION_DELAY...");

    // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏™‡∏≠‡∏á‡∏Ñ‡∏ô
    await nft.connect(user1).registerMember(1, owner.address);

    await ethers.provider.send("evm_increaseTime", [90]);
    await ethers.provider.send("evm_mine");

    await nft.connect(user2).registerMember(1, user1.address);
    console.log("‚úÖ ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢");

    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡πà‡∏≤‡∏á‡πÜ ‡∏ó‡∏µ‡πà‡∏°‡∏µ preventFrontRunning modifier

    // 1. ‡∏•‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å registerMember ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö registerMember ‡∏ã‡πâ‡∏≥‡∏ó‡∏±‡∏ô‡∏ó‡∏µ...");
    await expect(
      nft.connect(user1).registerMember(1, owner.address)
    ).to.be.revertedWithCustomError(nft, "AlreadyMember");
    console.log("‚úÖ AlreadyMember error ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");

    // 2. ‡∏•‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å upgradePlan ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å registerMember
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö upgradePlan ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á registerMember...");
    await expect(
      nft.connect(user2).upgradePlan(2)
    ).to.be.revertedWithCustomError(nft, "TooSoon");
    console.log("‚úÖ TooSoon error ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö upgradePlan ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á");

    console.log("üéâ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö MIN_ACTION_DELAY ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!");
  });

  it("Should block all forms of NFT transfers", async function () {
    const { nft, usdt, owner, user1, user2, decimals } = await loadFixture(
      deployFixture
    );

    console.log("üõ°Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô NFT...");

    // Register a member to get an NFT
    console.log("üìù ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö NFT...");
    await nft.connect(user1).registerMember(1, owner.address);

    const tokenId = await nft.tokenOfOwnerByIndex(user1.address, 0);
    console.log(`üé´ Token ID: ${tokenId}`);

    // Test transferFrom
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö transferFrom (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(user1).transferFrom(user1.address, user2.address, tokenId)
    ).to.be.revertedWithCustomError(nft, "NonTransferable");
    console.log("‚úÖ transferFrom ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test safeTransferFrom
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö safeTransferFrom (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft
        .connect(user1)
        ["safeTransferFrom(address,address,uint256)"](
          user1.address,
          user2.address,
          tokenId
        )
    ).to.be.revertedWithCustomError(nft, "NonTransferable");
    console.log("‚úÖ safeTransferFrom ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test safeTransferFrom with data
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö safeTransferFrom with data (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft
        .connect(user1)
        ["safeTransferFrom(address,address,uint256,bytes)"](
          user1.address,
          user2.address,
          tokenId,
          "0x"
        )
    ).to.be.revertedWithCustomError(nft, "NonTransferable");
    console.log("‚úÖ safeTransferFrom with data ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test approve - should not revert but should emit TransferAttemptBlocked
    console.log("‚ö†Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö approve (‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£ revert ‡πÅ‡∏ï‡πà‡∏Ñ‡∏ß‡∏£ emit event)...");
    try {
      const approveTx = await nft
        .connect(user1)
        .approve(user2.address, tokenId);
      const receipt = await approveTx.wait();

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ TransferAttemptBlocked event
      const transferBlockedEvent = receipt.logs.find((log) => {
        try {
          const parsed = nft.interface.parseLog({
            topics: log.topics,
            data: log.data,
          });
          return parsed.name === "TransferAttemptBlocked";
        } catch {
          return false;
        }
      });

      if (transferBlockedEvent) {
        console.log("‚úÖ TransferAttemptBlocked event emitted");
      } else {
        console.log("‚ö†Ô∏è No TransferAttemptBlocked event found");
      }
    } catch (error) {
      if (error.message.includes("NonTransferable")) {
        console.log("‚úÖ approve ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");
      } else {
        console.error("‚ùå Unexpected error:", error.message);
      }
    }

    // Test setApprovalForAll - should not revert but should emit TransferAttemptBlocked
    console.log(
      "‚ö†Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö setApprovalForAll (‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£ revert ‡πÅ‡∏ï‡πà‡∏Ñ‡∏ß‡∏£ emit event)..."
    );
    try {
      const setApprovalTx = await nft
        .connect(user1)
        .setApprovalForAll(user2.address, true);
      const receipt = await setApprovalTx.wait();

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ TransferAttemptBlocked event
      const transferBlockedEvent = receipt.logs.find((log) => {
        try {
          const parsed = nft.interface.parseLog({
            topics: log.topics,
            data: log.data,
          });
          return parsed.name === "TransferAttemptBlocked";
        } catch {
          return false;
        }
      });

      if (transferBlockedEvent) {
        console.log("‚úÖ TransferAttemptBlocked event emitted");
      } else {
        console.log("‚ö†Ô∏è No TransferAttemptBlocked event found");
      }
    } catch (error) {
      if (error.message.includes("NonTransferable")) {
        console.log("‚úÖ setApprovalForAll ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");
      } else {
        console.error("‚ùå Unexpected error:", error.message);
      }
    }

    // Verify token is still owned by original owner
    console.log("üîç ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ NFT ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°...");
    const currentOwner = await nft.ownerOf(tokenId);
    expect(currentOwner).to.equal(
      user1.address,
      "Token should still be owned by user1"
    );
    console.log("‚úÖ NFT ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°");

    // Verify balances haven't changed
    const user1Balance = await nft.balanceOf(user1.address);
    const user2Balance = await nft.balanceOf(user2.address);
    expect(user1Balance).to.equal(1, "User1 should still have 1 NFT");
    expect(user2Balance).to.equal(0, "User2 should have 0 NFTs");
    console.log("‚úÖ Balance ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á");

    console.log("üéâ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö NFT Transfer Blocking ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!");
  });

  it("Should prevent unauthorized access to owner-only functions", async function () {
    const { nft, usdt, owner, user1, decimals } = await loadFixture(
      deployFixture
    );

    console.log("üõ°Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô owner-only...");

    // Test setPaused
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö setPaused ‡πÇ‡∏î‡∏¢ non-owner (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(user1).setPaused(true)
    ).to.be.revertedWithCustomError(nft, "OwnableUnauthorizedAccount");
    console.log("‚úÖ setPaused ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test createPlan
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö createPlan ‡πÇ‡∏î‡∏¢ non-owner (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft
        .connect(user1)
        .createPlan(ethers.parseUnits("20", decimals), "Test Plan", 4)
    ).to.be.revertedWithCustomError(nft, "OwnableUnauthorizedAccount");
    console.log("‚úÖ createPlan ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test withdrawOwnerBalance
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö withdrawOwnerBalance ‡πÇ‡∏î‡∏¢ non-owner (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(user1).withdrawOwnerBalance(1)
    ).to.be.revertedWithCustomError(nft, "OwnableUnauthorizedAccount");
    console.log("‚úÖ withdrawOwnerBalance ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test requestEmergencyWithdraw
    console.log(
      "üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö requestEmergencyWithdraw ‡πÇ‡∏î‡∏¢ non-owner (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)..."
    );
    await expect(
      nft.connect(user1).requestEmergencyWithdraw()
    ).to.be.revertedWithCustomError(nft, "OwnableUnauthorizedAccount");
    console.log("‚úÖ requestEmergencyWithdraw ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test setPlanStatus
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö setPlanStatus ‡πÇ‡∏î‡∏¢ non-owner (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(user1).setPlanStatus(1, false)
    ).to.be.revertedWithCustomError(nft, "OwnableUnauthorizedAccount");
    console.log("‚úÖ setPlanStatus ‡∏ñ‡∏π‡∏Å‡∏ö‡∏•‡πá‡∏≠‡∏Å");

    // Test that owner CAN access these functions
    console.log("‚úÖ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ owner ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÑ‡∏î‡πâ...");

    // Owner should be able to pause
    await nft.connect(owner).setPaused(true);
    let contractStatus = await nft.getContractStatus();
    expect(contractStatus[0]).to.equal(true); // isPaused
    console.log("‚úÖ Owner ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ pause contract ‡πÑ‡∏î‡πâ");

    // Owner should be able to unpause
    await nft.connect(owner).restartAfterPause();
    contractStatus = await nft.getContractStatus();
    expect(contractStatus[0]).to.equal(false); // isPaused
    console.log("‚úÖ Owner ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ unpause contract ‡πÑ‡∏î‡πâ");

    console.log("üéâ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö Access Control ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!");
  });

  it("Should prevent reentrancy attacks", async function () {
    const { nft, usdt, owner, user1, user2, decimals } = await loadFixture(
      deployFixture
    );

    console.log("üõ°Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô Reentrancy Attack...");

    // Register members to create funds in the system
    console.log("üìù ‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö...");
    await nft.connect(user1).registerMember(1, owner.address);

    await ethers.provider.send("evm_increaseTime", [90]);
    await ethers.provider.send("evm_mine");

    await nft.connect(user2).registerMember(1, user1.address);
    console.log("‚úÖ ‡∏™‡∏°‡∏≤‡∏ä‡∏¥‡∏Å‡∏•‡∏á‡∏ó‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢");

    // Get system stats
    const systemStats = await nft.getSystemStats();
    const ownerBalance = systemStats[3];

    console.log(
      `üí∞ Owner balance in system: ${ethers.formatUnits(
        ownerBalance,
        decimals
      )} USDT`
    );

    if (ownerBalance > 0n) {
      // Test that withdrawal functions have reentrancy protection
      console.log("üîí ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô reentrancy ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ñ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô...");

      // This should work normally (single call)
      const withdrawAmount = ownerBalance / 2n;
      await nft.connect(owner).withdrawOwnerBalance(withdrawAmount);
      console.log("‚úÖ ‡∏Å‡∏≤‡∏£‡∏ñ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ");

      // Note: We can't easily test actual reentrancy attacks in this environment
      // but we can verify that the noReentrantTransfer modifier exists and
      // the functions are properly protected
      console.log(
        "üìã Contract ‡∏°‡∏µ noReentrantTransfer modifier ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô reentrancy"
      );
    }

    console.log("üéâ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö Reentrancy Protection ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!");
  });

  it("Should validate input parameters thoroughly", async function () {
    const { nft, owner, decimals } = await loadFixture(deployFixture);

    console.log("üõ°Ô∏è ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Input Parameters...");

    // Test plan creation with invalid values
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö createPlan ‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏≤‡∏Ñ‡∏≤ 0 (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(owner).createPlan(0, "Zero Price", 4)
    ).to.be.revertedWithCustomError(nft, "ZeroPrice");
    console.log("‚úÖ ZeroPrice validation ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");

    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö createPlan ‡∏î‡πâ‡∏ß‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ß‡πà‡∏≤‡∏á (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(owner).createPlan(ethers.parseUnits("1", decimals), "", 4)
    ).to.be.revertedWithCustomError(nft, "EmptyName");
    console.log("‚úÖ EmptyName validation ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");

    console.log(
      "üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö createPlan ‡∏î‡πâ‡∏ß‡∏¢ invalid cycle members (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)..."
    );
    await expect(
      nft
        .connect(owner)
        .createPlan(ethers.parseUnits("1", decimals), "Invalid", 5)
    ).to.be.revertedWithCustomError(nft, "InvalidCycleMembers");
    console.log("‚úÖ InvalidCycleMembers validation ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");

    // Test with extreme values that should work
    console.log("‚úÖ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö createPlan ‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡∏°‡∏≤‡∏Å (‡∏Ñ‡∏ß‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ)...");
    const extremelyHighPrice = ethers.parseUnits("1000000", decimals); // 1M USDT
    await nft
      .connect(owner)
      .createPlan(extremelyHighPrice, "Extremely High Price", 4);

    const plan = await nft.plans(17); // Should be the new plan
    expect(plan.price).to.equal(extremelyHighPrice);
    console.log("‚úÖ High price plan created successfully");

    // Test setPlanDefaultImage with invalid values
    console.log("üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö setPlanDefaultImage ‡∏î‡πâ‡∏ß‡∏¢ empty URI (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)...");
    await expect(
      nft.connect(owner).setPlanDefaultImage(1, "")
    ).to.be.revertedWithCustomError(nft, "EmptyURI");
    console.log("‚úÖ EmptyURI validation ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");

    console.log(
      "üö´ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö setPlanDefaultImage ‡∏î‡πâ‡∏ß‡∏¢ invalid plan ID (‡∏Ñ‡∏ß‡∏£‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)..."
    );
    await expect(
      nft.connect(owner).setPlanDefaultImage(0, "test")
    ).to.be.revertedWithCustomError(nft, "InvalidPlanID");
    console.log("‚úÖ InvalidPlanID validation ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô");

    console.log("üéâ ‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö Input Validation ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!");
  });
});
